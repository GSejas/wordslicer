#! /usr/bin/env python
#  -*- coding: utf-8 -*-
#
# Support module generated by PAGE version 4.14
# In conjunction with Tcl version 8.6
#    Aug 05, 2018 08:23:03 PM
#    Aug 05, 2018 09:28:37 PM
#    Aug 05, 2018 09:33:20 PM
#    Aug 07, 2018 06:27:58 PM
#    Aug 07, 2018 07:28:00 PM
#    Aug 08, 2018 08:18:39 PM
#    Aug 08, 2018 08:19:59 PM
#    Aug 08, 2018 08:21:23 PM
#    Aug 08, 2018 09:45:49 PM

import pysubs2
import random
import csv
import sys
import nltk
# nltk.download('punkt')
import os
import os.path
import configparser
import pandas
import json
import subprocess
import time
import multiprocessing
import threading
from datetime import datetime, timedelta
import xspf
from lxml import etree
##import vlc

FFMPEG_BIN = "ffmpeg" # on Linux ans Mac OS
FFPROBE = "ffprobe" # on Linux ans Mac OS
MKVMERGE_BIN = "mkvmerge" # on Linux ans Mac OS


try:
    from Tkinter import *
    #from Tkinter import filedialog
except ImportError:
    from tkinter import *
    #from tkinter import filedialog
#import Tkinter, Tkconstants, tkFileDialog
from tkinter import filedialog
try:
    import ttk
    py3 = False
except ImportError:
    import tkinter.ttk as ttk
    py3 = True









def add_media_2_db():
    threading.Thread(target=add_media_2_db_thread).start()

def add_media_2_db_thread():
    media_processing_state = True
    media_filename = "/home/jorge/Documents/Python Projects/WordSlicer/Vids/batman.and.harley.quinn.2017.german.bdrip.x264-contribution.mkv"
    media_name = os.path.basename(media_filename)
    subs_name = "/home/jorge/Documents/Python Projects/WordSlicer/Subs/batman.and.harley.quinn.2017.german.bdrip.x264-contribution.srt"
    media_name_in_db = False


    if subs_name != "" and media_filename != "" and not media_name_in_db:
        subs = pysubs2.load(subs_name, encoding="utf-8")
        subs_index = 0
        MOVIE_ARG_LIST = []
        for line in subs:
            if subs_index == 10:
                break
            subs_index = subs_index + 1

            # splittting the wrods
            word_list = nltk.word_tokenize(line.plaintext)


            # extracting subtitle data
            dur = line.duration
            startt = pysubs2.time.ms_to_str(line.start, True)
            endt = pysubs2.time.ms_to_str(line.end, True)

            # formatting subtitle information
            #sub_time = datetime(1, 1, 1) + timedelta(milliseconds=dur)


            # create mini video name
            video_split = media_name.split(".")
            if len(video_split) > 3:
                minivid_name = "_".join(video_split[0:-2]) + "_" + str(subs_index) + "." + video_split[-1]
            else:
                minivid_name = video_split[0] + "_" + str(subs_index) + "." + video_split[-1]

            subtext = line.plaintext
            # make a huge argument list to slice the video
            MOVIE_ARG_LIST.append((startt, endt, dur, media_filename, minivid_name, subtext))

        # create subprocesses to process the multiple mini vids
        count = 1
        total_minivids = len(MOVIE_ARG_LIST)
        print(total_minivids)
        start = time.time()
        with multiprocessing.Pool(6) as pool:
            for res in pool.imap_unordered(split_video, MOVIE_ARG_LIST):
                if media_processing_state:
                    vprogress_percentage = (count/total_minivids)*100
                    cur_current = time.time()
                    count = count + 1
                    rate = (cur_current - start)/(vprogress_percentage)
                    d = datetime(1, 1, 1) + timedelta(seconds=int(cur_current-start))
                    completion = datetime(1, 1, 1) + timedelta(seconds=int(((rate*100))))
                else:
                    break


    end = time.time()
    print(end - start)
    print('project_movie_slicer4_support.add_media_2_db')
    sys.stdout.flush()

    media_processing_state = False


def split_video(args):
    return _split_video(*args)

def _split_video(StartTime, StopTime, Duration, fullp_video, OutVideoName, subtext):
    OutVideoName_mp4_relpath = "TMP/"+OutVideoName+".mp4"
    # hash = random.getrandbits(128)
    # video_split = videofile.split(".")
    # if len(video_split)>3:
    #     OutputVideo = os.path.join("TMP/","_".join(video_split[0:-2])+"_"+str(index)+"."+video_split[-1])
    # else:
    #     OutputVideo = os.path.join("TMP/",video_split[0]+"_"+str(index)+"."+video_split[-1])

    #print(OutputVideo)
    #  VidFileExists = False
    VidFileExists = os.path.isfile(OutVideoName_mp4_relpath)

#ffmpeg -y
    # -i Vids/roor-bayonetta-sd.mkv
    # -r 30
    # -ss 0:00:59.240
    # -to 0:01:02.550
    # -vcodec copy
    # -acodec copy
    # -copyinkf slice_test_w_copyinkf_r_30.mp4

    cmdFFPEG = [FFMPEG_BIN,
                '-y',
                '-ss', StartTime,
                '-noaccurate_seek',
                '-i', fullp_video,
                # '-i',                    "TMP/"+OutVideoName+".srt",
                # '-vf',                    "subtitles=TMP/"+OutVideoName+".srt",

                '-t', "%06.3f" % (Duration/1000),
                '-vcodec', 'copy',
                '-acodec', 'copy',
                '-copyinkf',
                '-avoid_negative_ts', 'make_zero',
               # '-crf', '18',
                #  'scale="320:240"',
                # '-r','30',
                # '-s','160x90'
                OutVideoName_mp4_relpath]

    # if VidFileExists:
    #     if os.stat(OutVideoName_mp4_relpath).st_size != 0:
    #         process_to_execute(cmdFFPEG)
    # else:
    process_to_execute(cmdFFPEG)

    video_with_subs_name = OutVideoName_mp4_relpath + "subs.mp4"
    video_gif_with_subs_name = OutVideoName_mp4_relpath + "subs.mp4.gif"
    subtitle_filename = "TMP/" + OutVideoName + ".srt"
    vid_filter_optns = ["subtitles=" + subtitle_filename, "fps=30", "scale=320:-1"]

    # if subtitle doesnt exist, create it
    if not os.path.isfile(subtitle_filename):
        # creating a subtitle string
        duration_outvid = read_video_length(OutVideoName_mp4_relpath)[:-4]
        subtitle_info = "1\n" \
                        "00:00:00,000 ---> 0%s\n" \
                        % (duration_outvid.replace('.',
                                                   ','))+ subtext

        # saving subtitle string to a srt file in TMP
        unit_subtitle = pysubs2.SSAFile.from_string(subtitle_info)
        unit_subtitle.save(subtitle_filename)


    cmdFFPEG_addSUBS = [FFMPEG_BIN,
                        '-y',
                        '-i', OutVideoName_mp4_relpath,
                        '-vf',",".join(vid_filter_optns),
                        '-strict','-2',
                        video_with_subs_name]
    cmdFFPEG_gen_GIF = [FFMPEG_BIN,
                        '-y',
                        '-i', OutVideoName_mp4_relpath,
                        '-vf',",".join(vid_filter_optns),
                        '-strict','-2',
                        video_gif_with_subs_name]

    # if os.path.isfile(video_with_subs_name):
    #     if os.stat(video_with_subs_name).st_size != 0 :
    #         process_to_execute(cmdFFPEG_addSUBS)
    #         process_to_execute(cmdFFPEG_gen_GIF)
    # else:

    process_to_execute(cmdFFPEG_addSUBS)
    process_to_execute(cmdFFPEG_gen_GIF)

def read_video_length(VideoPath):

    cmdffprobe_readvlen = [FFPROBE,
                        '-i', os.path.abspath(VideoPath),
                        '-show_entries','format=duration',
                        '-sexagesimal',
                        '-v','quiet',
                        '-of','csv=%s' % ("p=0")]

    process = subprocess.Popen(cmdffprobe_readvlen, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    stdout, stderr = process.communicate()
    return stdout.decode('utf-8')

def process_to_execute(arg_list):

    process = subprocess.Popen(arg_list, stdout=subprocess.PIPE, stderr=subprocess.PIPE)

    stdout, stderr = process.communicate()
    if stderr is None:
        print("")
    else:
        with open("error.log", 'a') as err:
            err.write(stderr.decode('utf-8'))








add_media_2_db()


















