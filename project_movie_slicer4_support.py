#! /usr/bin/env python
#  -*- coding: utf-8 -*-
#
# Support module generated by PAGE version 4.14
# In conjunction with Tcl version 8.6
#    Aug 05, 2018 08:23:03 PM
#    Aug 05, 2018 09:28:37 PM
#    Aug 05, 2018 09:33:20 PM
#    Aug 07, 2018 06:27:58 PM
#    Aug 07, 2018 07:28:00 PM
#    Aug 08, 2018 08:18:39 PM
#    Aug 08, 2018 08:19:59 PM
#    Aug 08, 2018 08:21:23 PM
#    Aug 08, 2018 09:45:49 PM

import pysubs2
import random
import csv
import sys
import nltk
nltk.download('punkt')
import os
import os.path
import configparser
import pandas
import json
import subprocess
import time
import multiprocessing
import threading
from datetime import datetime, timedelta
from lxml import etree
##import vlc

FFMPEG_BIN = "ffmpeg" # on Linux ans Mac OS
MKVMERGE_BIN = "mkvmerge" # on Linux ans Mac OS

FFPROBE = "ffprobe" # on Linux ans Mac OS

try:
    from Tkinter import *
    #from Tkinter import filedialog
except ImportError:
    from tkinter import *
    #from tkinter import filedialog
#import Tkinter, Tkconstants, tkFileDialog
from tkinter import filedialog
try:
    import ttk
    py3 = False
except ImportError:
    import tkinter.ttk as ttk
    py3 = True



def generate_vid_cmd():
    word_name = search_word_var.get()
    track_list = []
    for element in datastore[word_name]:
        if os.path.isfile('TMP/'+element[5]) and os.stat('TMP/'+element[5]).st_size != 0 :
            if os.path.isfile('TMP/'+element[5]+'.srt'):
                track_list.append([os.path.abspath('TMP/'+element[5]), os.path.abspath('TMP/'+element[5]+'.srt')])

    if len(track_list) != 0:
        generate_xpiff(track_list)

def generate_xpiff(track_list):
    SPIFF_NS = "http://xspf.org/ns/0/"
    VLC_NS = "http://www.videolan.org/vlc/playlist/ns/0/"
    playlist = etree.Element('playlist', nsmap={None: SPIFF_NS, "vlc": VLC_NS})
    title = etree.SubElement(playlist, 'title')
    title.text = "Playlist_" + word_name
    tracklist = etree.SubElement(playlist, 'trackList')
    index_num = 0
    for element in track_list:
        track = etree.SubElement(tracklist, 'track')
        location = etree.SubElement(track, 'location')
        # point to absolute path of video file
        location.text = "file://" + element[0]
        extension = etree.SubElement(track, 'extension', application="http://www.videolan.org/vlc/playlist/0")
        id = etree.SubElement(extension, etree.QName(VLC_NS, 'id'))
        id.text = str(index_num)
        option = etree.SubElement(extension, etree.QName(VLC_NS, 'option'))
        option.text = "sub-file="+element[1]
        option = etree.SubElement(extension, etree.QName(VLC_NS, 'option'))
        option.text = "file-caching=300"
        index_num = index_num + 1
        extension = etree.SubElement(playlist, 'extension', application="http://www.videolan.org/vlc/playlist/0")
    #index_num = index_num - 1
    for idx in range(index_num):
        item = etree.SubElement(extension, etree.QName(VLC_NS, 'item'), tid="%s" %(idx))
    with open(word_name+".xspf", 'w') as f:
        f.write('<?xml version="1.0" encoding="UTF-8"?>\n')
        f.write(etree.tostring(playlist, pretty_print=True).decode("utf-8"))
    return




def btn_search_cmd():
    print("word searched: %s" % (search_word_var.get()))
    # print(datastore)
    tmp_list = []
    if search_word_var.get() in datastore:
        for element in datastore[search_word_var.get()]:
            tmp_list.append(element[4])
    words_found_list.set(tmp_list)


def add_media_2_db():
    threading.Thread(target=add_media_2_db_thread).start()

def add_media_2_db_thread():
    media_processing_state = True
    media_filename = media_url_txt.get()
    media_name = os.path.basename(media_filename)
    subs_name = subs_url_txt.get()
    media_name_in_db = False

    # if media was already processed
    if media_name in movies_in_db:
        # don't process this file
        media_name_in_db = True

    if os.path.isfile(MOVIE_DB_PATH):
        colnames = ['media_name', 'start', 'end', 'duration', 'wordlist', 'minivid_name']
        data = pandas.read_csv(MOVIE_DB_PATH, names=colnames)
        minivid_name_list = data.minivid_name.tolist()
    else:
        minivid_name_list = []

    if subs_name != "" and media_filename != "" and not media_name_in_db:
        subs = pysubs2.load(subs_name, encoding="utf-8")
        with open(MOVIE_DB_PATH, "a", encoding="utf-8") as mv_db:
            wr = csv.writer(mv_db, dialect='excel')
            subs_index = 0
            MOVIE_ARG_LIST = []
            for line in subs:
                subs_index = subs_index + 1

                # splittting the wrods
                word_list = nltk.word_tokenize(line.plaintext)


                # extracting subtitle data
                dur = line.duration
                startt = pysubs2.time.ms_to_str(line.start, True)
                endt = pysubs2.time.ms_to_str(line.end, True)

                # formatting subtitle information
                # sub_time = datetime(1, 1, 1) + timedelta(milliseconds=dur)


                # create mini video name
                video_split = media_name.split(".")
                if len(video_split) > 3:
                    minivid_name = "_".join(video_split[0:-2]) + "_" + str(subs_index) + "." + video_split[-1]
                else:
                    minivid_name = video_split[0] + "_" + str(subs_index) + "." + video_split[-1]

                # # if subtitle doesnt exist, create it
                # if not os.path.isfile("TMP/"+minivid_name+".srt"):
                #
                #     # creating a subtitle string
                #     subtitle_info = "1\n" \
                #                     "00:00:00,000 ---> %02d:%02d:%06.3f\n" \
                #                     "" % (sub_time.hour, sub_time.minute, sub_time.second+sub_time.microsecond/1000000)+line.plaintext
                #
                #
                #     # saving subtitle string to a srt file in TMP
                #     unit_subtitle = pysubs2.SSAFile.from_string(subtitle_info)
                #     unit_subtitle.save("TMP/"+minivid_name+".srt")

                # make a huge argument list to slice the video
                MOVIE_ARG_LIST.append((startt, endt, dur, media_filename, minivid_name, line.plaintext))

                # if video slice is not in db, add it
                if not minivid_name in minivid_name_list:
                    # writing to the database
                    wr.writerow([media_name, startt, endt, dur, word_list, minivid_name])

                # WORD DB LIST THING
                for word in word_list:
                    if word in datastore:
                        datastore[word].append([media_name, startt, endt, dur, word_list, minivid_name])
                    else:
                        datastore[word]=[[media_name, startt, endt, dur, word_list, minivid_name]]

                if subs_index==20:
                    break

        # create subprocesses to process the multiple mini vids
        count = 1
        total_minivids = len(MOVIE_ARG_LIST)
        print(total_minivids)
        start = time.time()
        with multiprocessing.Pool(3) as pool:
            for res in pool.imap_unordered(split_video, MOVIE_ARG_LIST):
                if media_processing_state:
                    vprogress_percentage = (count/total_minivids)*100
                    cur_current = time.time()
                    count = count + 1
                    rate = (cur_current - start)/(vprogress_percentage)
                    d = datetime(1, 1, 1) + timedelta(seconds=int(cur_current-start))
                    refresh_gui_split_progress(d, vprogress_percentage,rate)
                else:
                    break

        with open(JSON_PATH, 'w', encoding="utf-8") as outfile:
            json.dump(datastore, outfile)

        # if media name was not in the init config file list
        if not media_processing_state:
            movies_in_db.append(media_name)
            config['PROCESSED_MEDIA']['vid_name'] = ",".join(movies_in_db)
            with open(CONFIG_PATH, 'w') as configfile:
                config.write(configfile)

    end = time.time()
    #print(end - start)
    #print('project_movie_slicer4_support.add_media_2_db')
    #sys.stdout.flush()
    restore_gui_to_idle()

    media_processing_state = False

def restore_gui_to_idle():
    time_progressed.set("Idle")
    progress_percent.set("Idle")
    completion_time.set("Idle")

def refresh_gui_split_progress(d, vprogress_percentage,rate):
    progress_var.set(vprogress_percentage)
    completion = datetime(1, 1, 1) + timedelta(seconds=int(((rate*100))))
    progress_percent.set("Current progress %2.2f" % (vprogress_percentage))
    time_progressed.set("Time progressed : %02d:%02d:%02d" % (d.hour, d.minute, d.second))
    completion_time.set("ETA (min): %02d:%02d:%02d" % (completion.hour, completion.minute, completion.second))

def split_video(args):
    return _split_video(*args)

def _split_video(StartTime, StopTime, Duration, fullp_video, OutVideoName, subtext):
    ext = ".webm"
    #ext = ".mp4"

    OutVideoName_mp4_relpath = "TMP/"+OutVideoName+".mp4"
    video_with_subs_name = OutVideoName_mp4_relpath + "subs." + ext
    video_gif_with_subs_name = OutVideoName_mp4_relpath + "subs." + ext + ".gif"
    subtitle_filename = "TMP/" + OutVideoName + ".srt"

    #print(OutputVideo)
    #  VidFileExists = False
    VidFileExists = os.path.isfile(OutVideoName_mp4_relpath)

# model command
#ffmpeg -y
    # -i Vids/roor-bayonetta-sd.mkv
    # -r 30
    # -ss 0:00:59.240
    # -to 0:01:02.550
    # -vcodec copy
    # -acodec copy
    # -copyinkf slice_test_w_copyinkf_r_30.mp4
    if 0:
        cmdFFPEG = [FFMPEG_BIN,
                    '-y',
                    '-ss', StartTime,
                    '-noaccurate_seek',
                    '-i', fullp_video,
                    # '-i',                    "TMP/"+OutVideoName+".srt",
                    # '-vf',                    "subtitles=TMP/"+OutVideoName+".srt",
                    '-t', "%06.3f" % (Duration/1000), # specify the duration in floating
                    '-vcodec', 'copy', # copy the codec
                    '-acodec', 'copy', # copy the codec
                    '-copyinkf',
                    '-avoid_negative_ts', 'make_zero',
                    OutVideoName_mp4_relpath]
    else:
        cmdFFPEG = [FFMPEG_BIN,
                    '-y',
                   # '-noaccurate_seek',
                    '-i', fullp_video,
                    '-ss', StartTime,
                    # '-i',                    "TMP/"+OutVideoName+".srt",
                    # '-vf',                    "subtitles=TMP/"+OutVideoName+".srt",
                    '-t', "%06.3f" % (Duration/1000), # specify the duration in floating
                   # '-vcodec', 'copy', # copy the codec
                  #  '-acodec', 'copy', # copy the codec
                  #  '-copyinkf',
                    '-avoid_negative_ts', 'make_zero',
                    OutVideoName_mp4_relpath]

    process_to_execute(cmdFFPEG)

    # if subtitle doesnt exist, create it
    if not os.path.isfile(subtitle_filename):
        # creating a subtitle string
        duration_outvid = read_video_length(OutVideoName_mp4_relpath)[:-4]
        subtitle_info = "1\n" \
                        "00:00:00,000 ---> 0%s\n" \
                        % (duration_outvid.replace('.',
                                                   ','))+ subtext

        # saving subtitle string to a srt file in TMP
        unit_subtitle = pysubs2.SSAFile.from_string(subtitle_info)
        unit_subtitle.save(subtitle_filename)

    # make options for filtered video with subs
    vid_filter_optns = ["subtitles=" + subtitle_filename, "fps=30", "scale=320:-1"]

    # make command for filtered video with subs
    cmdFFPEG_addSUBS = [FFMPEG_BIN,
                        '-y',
                        '-i', OutVideoName_mp4_relpath,
                        '-vf',",".join(vid_filter_optns),
                        '-strict','-2',
                        video_with_subs_name]

    # process filtered video with subs
    process_to_execute(cmdFFPEG_addSUBS)
    
    vid_filter_optns2 = ["fps=30", "scale=320:-1"]

    cmdFFPEG_make_Webm = [FFMPEG_BIN,
                        '-y',
                        '-i', OutVideoName_mp4_relpath,
                        '-vf',",".join(vid_filter_optns2),
                        '-strict','-2',
                        OutVideoName_mp4_relpath+".webm"]

    process_to_execute(cmdFFPEG_make_Webm)

    if 0:
        cmdFFPEG_gen_GIF = [FFMPEG_BIN,
                            '-y',
                            '-i', OutVideoName_mp4_relpath,
                            '-vf',",".join(vid_filter_optns),
                            '-strict','-2',
                            video_gif_with_subs_name]

        process_to_execute(cmdFFPEG_gen_GIF)

# function to retrieve the final size of video
def read_video_length(VideoPath):

    cmdffprobe_readvlen = [FFPROBE,
                        '-i', os.path.abspath(VideoPath),
                        '-show_entries','format=duration',
                        '-sexagesimal',
                        '-v','quiet',
                        '-of','csv=%s' % ("p=0")]

    process = subprocess.Popen(cmdffprobe_readvlen, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    stdout, stderr = process.communicate()
    return stdout.decode('utf-8')


def process_to_execute(arg_list):

    process = subprocess.Popen(arg_list, stdout=subprocess.PIPE, stderr=subprocess.PIPE)

    stdout, stderr = process.communicate()
    if stderr is None:
        print("")
    else:
        with open("error.log", 'a') as err:
            err.write(stderr.decode('utf-8'))

# This function creates the .ini file or reads the values within.
def read_init_config_file():
    global JSON_PATH, CONFIG_PATH, MOVIE_DB_PATH
    global datastore, config, movies_in_db

    global media_processing_state
    media_processing_state = False  # type: bool

    MOVIE_DB_PATH = os.path.abspath('movie_database.csv')
    JSON_PATH = os.path.abspath("word_database.json")
    CONFIG_PATH = os.path.abspath('wordslicer.ini')

    datastore = {}
    config = configparser.ConfigParser()

    # Read JSON data into the datastore variable
    if os.path.isfile(JSON_PATH) and os.access(JSON_PATH, os.R_OK):
        with open(JSON_PATH, 'r',encoding="utf-8") as json_file:
            datastore = json.load(json_file)

    if os.path.isfile(CONFIG_PATH) and os.access(CONFIG_PATH, os.R_OK):
        config.read(CONFIG_PATH)
        #with open(PATH, "r") as ini_f:
        movies_in_db = config['PROCESSED_MEDIA']['vid_name'].split(",")
        old_media_name = config['MEDIA_OLD_ENTRY']['media']
        old_sub_name = config['MEDIA_OLD_ENTRY']['subs']
        media_url_txt.set(old_media_name)
        subs_url_txt.set(old_sub_name)

    else:
        config['MEDIA_OLD_ENTRY']={}
        config['PROCESSED_MEDIA']={'vid_name':""}
        config['MEDIA_OLD_ENTRY']['media']=" "
        config['MEDIA_OLD_ENTRY']['subs']=" "
        with open(CONFIG_PATH, 'w') as configfile:
            config.write(configfile)

def set_Tk_var():
    global add_button_state
    add_button_state = "normal"
    global media_url_txt
    media_url_txt = StringVar()
    global subs_url_txt
    subs_url_txt = StringVar()
    global progress_var
    progress_var = IntVar()
    global time_progressed
    time_progressed = StringVar()
    time_progressed.set("Idle")
    global progress_percent
    progress_percent = StringVar()
    progress_percent.set("Idle")
    global completion_time
    completion_time = StringVar()
    completion_time.set("Idle")
    global combobox
    combobox = StringVar()
    combobox.set('var')
    combobox.set('another')
    global combobox_list
    combobox_list = [""]
    global search_word_var
    search_word_var = StringVar()
    global words_found_list
    words_found_list = StringVar()

def button_press(event):

    widget = event.widget

    element = widget.identify(event.x, event.y)

    if "close" in element:
        index = widget.index("@%d,%d" % (event.x, event.y))
        widget.state(['pressed'])
        widget._active = index

def button_release(event):

    widget = event.widget

    if not widget.instate(['pressed']):
            return

    element = widget.identify(event.x, event.y)

    try:
        index = widget.index("@%d,%d" % (event.x, event.y))
    except TclError:
        pass

    if "close" in element and widget._active == index:
        widget.forget(index)
        widget.event_generate("<<NotebookTabClosed>>")

    widget.state(["!pressed"])
    widget._active = None

def delete_movie():
    #os.remove(MOVIE_DB_PATH)
    if os.path.isfile(MOVIE_DB_PATH):
        os.remove(MOVIE_DB_PATH)
    for folderName, subfolders, filenames in os.walk('TMP'):
        for file in filenames:
            #print()
            os.remove(os.path.join(folderName, file))
    #sys.stdout.flush()

def load_media_file():
    filename = filedialog.askopenfilename(filetypes= (("All files", "*.*") ))
    if isinstance(filename, str):
        media_url_txt.set(filename)
        config = configparser.ConfigParser()
        config.read('wordslicer.ini')
        # config['MEDIA_OLD_ENTRY']={}
        config['MEDIA_OLD_ENTRY']['media']=filename
        with open('wordslicer.ini', 'w') as configfile:
            config.write(configfile)


def load_sub_file():
    filename = filedialog.askopenfilename(filetypes = (("Sub files", "*.srt")
                                                         ,("All files", "*.*")))
    if isinstance(filename, str):
        subs_url_txt.set(filename)
        config = configparser.ConfigParser()
        config.read('wordslicer.ini')
        # config['MEDIA_OLD_ENTRY']={}
        config['MEDIA_OLD_ENTRY']['subs']=filename
        with open('wordslicer.ini', 'w') as configfile:
            config.write(configfile)


def mouse_over(event):

    widget = event.widget
    element = widget.identify(event.x, event.y)

    if "close" in element:
        widget.state(['alternate'])

    else:
        widget.state(['!alternate'])

def init(top, gui, *args, **kwargs):
    read_init_config_file()
    global w, top_level, root
    w = gui
    top_level = top
    root = top

def destroy_window():
    # Function which closes the window.
    global top_level
    top_level.destroy()
    top_level = None

if __name__ == '__main__':
    media_processing_state = False
    import project_movie_slicer4
    project_movie_slicer4.vp_start_gui()

























